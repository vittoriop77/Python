# -*- coding: utf-8 -*-
"""Nasdaq con strategia 10gg ATR e SMA.ipynb

Automatically generated by Colab.

"""

import yfinance as yf
import pandas as pd
import requests
from io import StringIO
from datetime import datetime, timedelta

def get_tickers():
    """Ottiene la lista completa dei ticker """
    url = "https://yfiua.github.io/index-constituents/constituents-nasdaq100.csv" #Nasdaq
    #url = "https://yfiua.github.io/index-constituents/constituents-sp500.csv" #SP500
    response = requests.get(url)
    df = pd.read_csv(StringIO(response.text), sep=",")
    # Restituisce tutti i ticker senza filtri
    tickers = df['Symbol'].tolist()
    return tickers
    #return [t for t in tickers if t.isalpha() and len(t) <= 4]  # Filtra simboli ragionevoli

tickers = get_tickers()
print(f"Trovati {len(tickers)} ticker ")

def find_losers(tickers):
    """Step 1: Trova le azioni con calo > threshold%"""
    threshold=-3.0
    max_tickers=500
    # Limita il numero di ticker per velocità
    tickers = tickers[:max_tickers]

    try:
        # Scarica dati di 2 giorni per trovare i losers
        data_2d = yf.download(tickers, period="2d", auto_adjust=False)['Close']

        if len(data_2d.columns) == 1:
            prev_close = data_2d.iloc[0]
            last_close = data_2d.iloc[1]
            pct_change = ((last_close - prev_close) / prev_close * 100).to_frame().T
            pct_change.columns = [data_2d.columns[0]]
        else:
            prev_close = data_2d.iloc[0]
            last_close = data_2d.iloc[1]
            pct_change = (last_close - prev_close) / prev_close * 100

        # Filtra azioni con calo > threshold%
        losers = pct_change[pct_change < threshold].dropna()

        if isinstance(losers, pd.Series):
            losers_data = losers
        else:
            if isinstance(losers, pd.DataFrame):
                losers_data = losers.iloc[0] if len(losers) > 0 else pd.Series()
            else:
                losers_data = losers

        if losers_data.empty:
            print(f"Nessuna azione con calo > {abs(threshold)}%")
            return []

        # Prepara lista di dizionari con i dati dei losers
        losers_list = []
        for ticker, change in losers_data.items():
            losers_list.append({
                'ticker': ticker,
                'daily_change': change
            })

        #print(f"\nTrovate {len(losers_list)} azioni con calo > {abs(threshold)}%")
        return losers_list

    except Exception as e:
        print(f"Errore nel download dei dati: {e}")
        return []

print("=== STEP 1: Ricerca dei losers  ===")
losers = find_losers(tickers)
print(losers) # Aggiunto per stampare il contenuto della variabile losers

# Funzione per verificare se il prezzo è sopra la SMA200
def is_above_sma200(ticker):
    data = yf.Ticker(ticker).history(period='250d')  # Prendi almeno 250 giorni per sicurezza
    if data.empty:
        return False
    data['SMA200'] = data['Close'].rolling(window=200).mean()
    last_close = data['Close'].iloc[-1]
    last_sma200 = data['SMA200'].iloc[-1]
    if pd.isna(last_sma200):
        return False
    return last_close > last_sma200

# Filtra i ticker sopra la SMA200
print("=== STEP 2: Ricerca dei rialzisti  ===")
rialzisti = [entry for entry in losers if is_above_sma200(entry['ticker'])]
print(rialzisti)

def filter_by_atr(tickers, atr_threshold=0.03):

    # Se input lista di dizionari, estrai solo ticker
    if isinstance(tickers[0], dict):
        ticker_list = [t['ticker'] for t in tickers if 'ticker' in t]
    else:
        ticker_list = tickers

    # Scarica i dati degli ultimi 6 giorni per tutti i ticker in blocco
    data = yf.download(ticker_list, period='6d', group_by='ticker', threads=True, progress=False, auto_adjust=False)

    filtered_tickers = []
    atr_values = {}

    for ticker in ticker_list:
        # Controlla se i dati per il ticker esistono e non sono vuoti
        if ticker not in data.columns.levels[0]:
            continue

        df = data[ticker].dropna()
        if df.shape[0] < 6:
            continue

        df['prev_close'] = df['Close'].shift(1)
        df = df.dropna()

        tr1 = df['High'] - df['Low']
        tr2 = (df['High'] - df['prev_close']).abs()
        tr3 = (df['Low'] - df['prev_close']).abs()

        true_range = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
        atr_5 = true_range.tail(5).mean()

        if atr_5 > atr_threshold:
            filtered_tickers.append(ticker)
            #filtered_tickers.append(ticker, atr_5)
            atr_values[ticker] = atr_5

    return filtered_tickers, atr_values

print("=== STEP 3: Ricerca dei ticker con volatilità > 0.03  ===")
lista_finale, atrs = filter_by_atr(rialzisti, atr_threshold=0.03)
#lista_finale = filter_by_atr(rialzisti, atr_threshold=0.03)
print(lista_finale)

def calculate_support_levels(lista_finale, atrs):
    """
    Calcola per ogni ticker il valore dell'ultima chiusura meno 1/2 ATR

    Args:
        lista_finale: lista dei ticker filtrati
        atrs: dizionario con i valori ATR per ogni ticker

    Returns:
        dict: dizionario con ticker come chiavi e livelli di supporto come valori
    """
    import yfinance as yf

    # Scarica i dati dell'ultimo giorno per ottenere l'ultima chiusura
    data = yf.download(lista_finale, period='1d', group_by='ticker', threads=True, progress=False, auto_adjust=False)

    support_levels = {}

    for ticker in lista_finale:
        try:
            # Se c'è un solo ticker, yfinance non usa il multi-index
            if len(lista_finale) == 1:
                last_close = data['Close'].iloc[-1]
            else:
                # Controlla se i dati per il ticker esistono
                if ticker not in data.columns.levels[0]:
                    print(f"Dati non disponibili per {ticker}")
                    continue

                last_close = data[ticker]['Close'].iloc[-1]

            # Calcola il livello di supporto: ultima chiusura - (ATR / 2)
            atr = atrs[ticker]
            support_level = last_close - (atr / 2)

            support_levels[ticker] = {
                'last_close': last_close,
                'atr': atr,
                'support_level': support_level
            }

        except Exception as e:
            print(f"Errore nel calcolo per {ticker}: {e}")
            continue

    return support_levels

livelli_supporto = calculate_support_levels(lista_finale, atrs)

# Stampa i risultati
for ticker, info in livelli_supporto.items():
    print(f"{ticker}: Chiusura={info['last_close']:.2f}, ATR={info['atr']:.4f}, Supporto={info['support_level']:.2f}")

def check_sell_conditions(ticker, data_acquisto):
    """
    Controlla le condizioni di vendita per un ticker:
    - Se sono passati 10 giorni dalla data di acquisto
    - Se la chiusura odierna è sopra il massimo del giorno precedente

    Args:
        ticker: simbolo del ticker (str)
        data_acquisto: data di acquisto in formato 'YYYY-MM-DD' (str) o datetime

    Returns:
        str: messaggio con la decisione (MANTIENI o VENDI A xxx)
    """

    try:
        # Converti la data di acquisto in datetime se è una stringa
        if isinstance(data_acquisto, str):
            data_acquisto = datetime.strptime(data_acquisto, '%Y-%m-%d')

        # Data odierna
        oggi = datetime.now()

        # Calcola i giorni trascorsi
        giorni_trascorsi = (oggi - data_acquisto).days

        # Scarica i dati degli ultimi 3 giorni per avere oggi e ieri
        data = yf.download(ticker, period='3d', progress=False, auto_adjust=False)

        if data.empty or len(data) < 2:
            return f"ERRORE: Dati insufficienti per {ticker}"

        # Ottieni i dati di oggi e ieri (estraendo i valori numerici)
        chiusura_oggi = data['Close'].iloc[-1].item()
        massimo_ieri = data['High'].iloc[-2].item()

        # Condizione 1: sono passati 10 giorni?
        condizione_tempo = giorni_trascorsi >= 10

        # Condizione 2: chiusura oggi sopra massimo di ieri?
        condizione_breakout = chiusura_oggi > massimo_ieri

        # Decisione di vendita
        if condizione_tempo or condizione_breakout:
            motivo = []
            if condizione_tempo:
                motivo.append(f"10 giorni trascorsi ({giorni_trascorsi})")
            if condizione_breakout:
                motivo.append(f"breakout (chiusura {chiusura_oggi:.2f} > max ieri {massimo_ieri:.2f})")

            motivo_str = " - ".join(motivo)
            return f"VENDI A {chiusura_oggi:.2f} - Motivo: {motivo_str}"
        else:
            return f"MANTIENI - Giorni: {giorni_trascorsi}/10, Chiusura: {chiusura_oggi:.2f}, Max ieri: {massimo_ieri:.2f}"

    except Exception as e:
        return f"ERRORE per {ticker}: {e}"

# Esempio di utilizzo:
#decisione = check_sell_conditions('AAPL', '2025-07-21')
#print(decisione)
